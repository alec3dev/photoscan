<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Face Detection and Cropping</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    h1 { color: #333; text-align: center; }
    .upload-section {
      margin-bottom: 20px;
      padding: 15px;
      border: 2px dashed #ccc;
      border-radius: 5px;
      text-align: center;
    }
    .button {
      background-color: #4CAF50;
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }
    .button:disabled { background-color: #cccccc; cursor: not-allowed; }
    .button:hover:not(:disabled) { background-color: #45a049; }
    .results {
      margin-top: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
    }
    .face-card {
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
      text-align: center;
      background-color: #f9f9f9;
    }
    .face-image { max-width: 100%; height: auto; border-radius: 3px; }
    .status {
      margin: 10px 0;
      padding: 10px;
      border-radius: 4px;
    }
    .loading { background-color: #e0f7fa; color: #006064; }
    .success { background-color: #e8f5e9; color: #2e7d32; }
    .error { background-color: #ffebee; color: #c62828; }
    textarea {
      width: 100%;
      height: 100px;
      margin: 10px 0;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: vertical;
    }
    .instructions {
      background-color: #fff3e0;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Face Detection and Cropping Tool</h1>

  <div class="instructions">
    <h3>Instructions:</h3>
    <ol>
      <li>Upload an image containing faces</li>
      <li>Enter numbers/names (one per line) to assign to detected faces</li>
      <li>Click "Detect and Crop Faces" to process the image</li>
      <li>Download the cropped face images using the download buttons</li>
    </ol>
  </div>

  <div class="upload-section">
    <h3>Upload Image</h3>
    <input type="file" id="imageUpload" accept="image/*">
    <div id="imagePreview"></div>
  </div>

  <div>
    <h3>Enter Identifiers (one per line):</h3>
    <textarea id="identifiers" placeholder="Enter numbers or names, one per line. These will be used as filenames for the cropped faces."></textarea>
  </div>

  <div>
    <button id="processButton" class="button" disabled>Detect and Crop Faces</button>
    <button id="downloadAllButton" class="button" disabled>Download All</button>
  </div>

  <div id="status" class="status"></div>

  <h3>Detected Faces:</h3>
  <div id="results" class="results"></div>
</div>

<!-- Face API.js -->
<script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>
<!-- JSZip -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script>
let imageFile = null;
let detectedFaces = [];

const imageUpload = document.getElementById('imageUpload');
const imagePreview = document.getElementById('imagePreview');
const identifiersTextarea = document.getElementById('identifiers');
const processButton = document.getElementById('processButton');
const downloadAllButton = document.getElementById('downloadAllButton');
const statusDiv = document.getElementById('status');
const resultsDiv = document.getElementById('results');

imageUpload.addEventListener('change', handleImageUpload);
processButton.addEventListener('click', processImage);
downloadAllButton.addEventListener('click', downloadAllFaces);

async function initializeFaceAPI() {
  statusDiv.textContent = 'Loading face detection models...';
  statusDiv.className = 'status loading';
  try {
    await faceapi.nets.tinyFaceDetector.loadFromUri('https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/');
    await faceapi.nets.faceLandmark68Net.loadFromUri('https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/');
    statusDiv.textContent = 'Models loaded successfully. Ready to detect faces.';
    statusDiv.className = 'status success';
  } catch (error) {
    statusDiv.textContent = `Error loading models: ${error.message}`;
    statusDiv.className = 'status error';
    console.error(error);
  }
}

function handleImageUpload(event) {
  const file = event.target.files[0];
  if (!file) return;
  imageFile = file;
  resultsDiv.innerHTML = '';
  detectedFaces = [];
  downloadAllButton.disabled = true;
  const reader = new FileReader();
  reader.onload = function(e) {
    imagePreview.innerHTML = `<img src="${e.target.result}" style="max-width: 100%; max-height: 300px;">`;
    processButton.disabled = false;
  };
  reader.readAsDataURL(file);
}

function centerPoint(points) {
  const xs = points.map(p => p.x);
  const ys = points.map(p => p.y);
  return {
    x: xs.reduce((a,b)=>a+b,0)/points.length,
    y: ys.reduce((a,b)=>a+b,0)/points.length
  };
}

async function processImage() {
  if (!imageFile) return;
  statusDiv.textContent = 'Detecting faces...';
  statusDiv.className = 'status loading';
  processButton.disabled = true;

  try {
    // Get identifiers from textarea
    const identifiers = identifiersTextarea.value.split('\n').map(id => id.trim()).filter(id => id !== '');

    // Load the image
    const img = await faceapi.bufferToImage(imageFile);

    // Detect faces with landmarks
    const detections = await faceapi
      .detectAllFaces(img, new faceapi.TinyFaceDetectorOptions())
      .withFaceLandmarks();

    if (detections.length === 0) {
      statusDiv.textContent = 'No faces detected in the image.';
      statusDiv.className = 'status error';
      processButton.disabled = false;
      return;
    }

    statusDiv.textContent = `Detected ${detections.length} faces. Processing...`;

    detectedFaces = detections.map((detection, index) => {
      const landmarks = detection.landmarks;
      const box = detection.detection.box;

      // Calculate rotation angle using eyes
      const leftEyeCenter = centerPoint(landmarks.getLeftEye());
      const rightEyeCenter = centerPoint(landmarks.getRightEye());
      const dx = rightEyeCenter.x - leftEyeCenter.x;
      const dy = rightEyeCenter.y - leftEyeCenter.y;
      const angle = Math.atan2(dy, dx);

      // Create canvas for the face
      const width = box.width * 1.5;  // initial box expansion
      const height = box.height * 1.8;
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      // Draw rotated face
      ctx.translate(width / 2, height / 2);
      ctx.rotate(-angle);
      ctx.drawImage(
        img,
        box.x - width/4, box.y - height/3, width, height,
        -width / 2, -height / 2, width, height
      );
      ctx.setTransform(1, 0, 0, 1, 0, 0);

      // Tight crop using landmarks
      const allPoints = [
        ...landmarks.getJawOutline(),
        ...landmarks.getLeftEye(),
        ...landmarks.getRightEye(),
        ...landmarks.getNose(),
        ...landmarks.getMouth()
      ];

      let xs = allPoints.map(p => p.x);
      let ys = allPoints.map(p => p.y);
      let minX = Math.min(...xs);
      let maxX = Math.max(...xs);
      let minY = Math.min(...ys);
      let maxY = Math.max(...ys);

      // Padding: hair + neck + small horizontal
      const paddingTop = (maxY - minY) * 0.4; // hair
      const paddingBottom = (maxY - minY) * 0.25; // neck
      const paddingSide = (maxX - minX) * 0.15; // ears

      minX = Math.max(0, minX - paddingSide - box.x);
      maxX = Math.min(width, maxX + paddingSide - box.x);
      minY = Math.max(0, minY - paddingTop - box.y);
      maxY = Math.min(height, maxY + paddingBottom - box.y);

      let cropWidth = maxX - minX;
      let cropHeight = maxY - minY;

      // Adjust to 2:3 ratio (width:height)
      const targetRatio = 2 / 3;
      if (cropWidth / cropHeight > targetRatio) {
        // too wide, increase height
        const newHeight = cropWidth / targetRatio;
        const delta = newHeight - cropHeight;
        minY = Math.max(0, minY - delta / 2);
        maxY = Math.min(height, maxY + delta / 2);
        cropHeight = maxY - minY;
      } else {
        // too tall, increase width
        const newWidth = cropHeight * targetRatio;
        const delta = newWidth - cropWidth;
        minX = Math.max(0, minX - delta / 2);
        maxX = Math.min(width, maxX + delta / 2);
        cropWidth = maxX - minX;
      }

      // Final cropped canvas
      const croppedCanvas = document.createElement('canvas');
      croppedCanvas.width = cropWidth;
      croppedCanvas.height = cropHeight;
      const croppedCtx = croppedCanvas.getContext('2d');
      croppedCtx.drawImage(canvas, minX, minY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

      const identifier = index < identifiers.length ? identifiers[index] : `face_${index + 1}`;
      return {
        id: identifier,
        imageData: croppedCanvas.toDataURL('image/jpeg'),
        x: box.x,
        y: box.y,
        width: box.width,
        height: box.height
      };
    });

    // Sort faces (top to bottom, left to right)
    detectedFaces.sort((a, b) => Math.abs(a.y - b.y) < a.height * 0.5 ? a.x - b.x : a.y - b.y);
    detectedFaces.forEach((face, index) => {
      if (index < identifiers.length) face.id = identifiers[index];
      else face.id = `face_${index + 1}`;
    });

    displayResults();
    statusDiv.textContent = `Successfully processed ${detectedFaces.length} faces.`;
    statusDiv.className = 'status success';
    downloadAllButton.disabled = false;
  } catch (error) {
    statusDiv.textContent = `Error processing image: ${error.message}`;
    statusDiv.className = 'status error';
    console.error(error);
    processButton.disabled = false;
  }
}

function displayResults() {
  resultsDiv.innerHTML = '';
  detectedFaces.forEach(face => {
    const card = document.createElement('div');
    card.className = 'face-card';
    card.innerHTML = `
      <img src="${face.imageData}" class="face-image" alt="Cropped face">
      <p>${face.id}</p>
      <button class="button download-btn" data-id="${face.id}">Download</button>
    `;
    resultsDiv.appendChild(card);
  });
  document.querySelectorAll('.download-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = btn.getAttribute('data-id');
      downloadFace(id);
    });
  });
}

function downloadFace(id) {
  const face = detectedFaces.find(f => f.id===id);
  if(!face) return;
  const link = document.createElement('a');
  link.href = face.imageData;
  link.download = `${id}.jpg`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

async function downloadAllFaces() {
  if(detectedFaces.length===0) return;
  statusDiv.textContent = 'Preparing download...';
  statusDiv.className = 'status loading';
  try {
    const zip = new JSZip();
    detectedFaces.forEach(face=>{
      const data = face.imageData.split(',')[1];
      const blob = base64ToBlob(data,'image/jpeg');
      zip.file(`${face.id}.jpg`, blob);
    });
    const content = await zip.generateAsync({type:'blob'});
    const link = document.createElement('a');
    link.href = URL.createObjectURL(content);
    link.download = 'cropped_faces.zip';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    statusDiv.textContent='Download prepared successfully.';
    statusDiv.className='status success';
  } catch(error){
    statusDiv.textContent=`Error creating zip file: ${error.message}`;
    statusDiv.className='status error';
    console.error(error);
  }
}

function base64ToBlob(base64, mimeType){
  const byteCharacters = atob(base64);
  const byteArrays = [];
  for(let offset=0; offset<byteCharacters.length; offset+=512){
    const slice = byteCharacters.slice(offset, offset+512);
    const byteNumbers = new Array(slice.length);
    for(let i=0;i<slice.length;i++) byteNumbers[i]=slice.charCodeAt(i);
    const byteArray = new Uint8Array(byteNumbers);
    byteArrays.push(byteArray);
  }
  return new Blob(byteArrays,{type:mimeType});
}

initializeFaceAPI();
</script>
</body>
</html>

