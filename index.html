<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Document Scanner</title>
<link rel="stylesheet" href="styles.css">
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>
<body>
<div class="container">
  <h1>Document Scanner</h1>
  <input type="file" id="fileInput" accept="image/*">
  <button id="processBtn">Process Document</button>
  <canvas id="sourceCanvas"></canvas>
  <canvas id="resultCanvas"></canvas>
</div>

<script>
let srcCanvas = document.getElementById('sourceCanvas');
let resCanvas = document.getElementById('resultCanvas');
let srcCtx = srcCanvas.getContext('2d');
let img = new Image();

document.getElementById('fileInput').addEventListener('change', e => {
  let file = e.target.files[0];
  if (!file) return;
  let reader = new FileReader();
  reader.onload = ev => {
    img.onload = () => {
      srcCanvas.width = img.width;
      srcCanvas.height = img.height;
      srcCtx.drawImage(img, 0, 0);
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
});

document.getElementById('processBtn').addEventListener('click', () => {
  if (typeof cv === 'undefined') {
    alert('OpenCV.js not loaded yet');
    return;
  }
  let src = cv.imread(srcCanvas);

  // 1. Convert to gray and detect edges
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
  let edges = new cv.Mat();
  cv.Canny(gray, edges, 75, 200);

  // 2. Find contours and pick the largest quadrilateral
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
  let maxArea = 0;
  let docContour = null;
  for (let i = 0; i < contours.size(); ++i) {
    let cnt = contours.get(i);
    let peri = cv.arcLength(cnt, true);
    let approx = new cv.Mat();
    cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
    if (approx.rows === 4) {
      let area = cv.contourArea(approx);
      if (area > maxArea) {
        maxArea = area;
        docContour = approx;
      }
    }
  }
  if (!docContour) {
    alert('Could not find a document contour');
    src.delete(); gray.delete(); edges.delete();
    contours.delete(); hierarchy.delete();
    return;
  }

  // 3. Order points and compute perspective transform
  let pts = [];
  for (let i = 0; i < 4; i++) {
    pts.push({x: docContour.intPtr(i,0)[0], y: docContour.intPtr(i,0)[1]});
  }
  // sort: top-left, top-right, bottom-right, bottom-left
  pts.sort((a,b)=>a.y-b.y);
  let top = pts.slice(0,2).sort((a,b)=>a.x-b.x);
  let bottom = pts.slice(2).sort((a,b)=>a.x-b.x);
  let ordered = [top[0], top[1], bottom[1], bottom[0]];

  let widthTop = Math.hypot(ordered[1].x - ordered[0].x, ordered[1].y - ordered[0].y);
  let widthBottom = Math.hypot(ordered[2].x - ordered[3].x, ordered[2].y - ordered[3].y);
  let maxWidth = Math.max(widthTop, widthBottom);
  let heightLeft = Math.hypot(ordered[3].x - ordered[0].x, ordered[3].y - ordered[0].y);
  let heightRight = Math.hypot(ordered[2].x - ordered[1].x, ordered[2].y - ordered[1].y);
  let maxHeight = Math.max(heightLeft, heightRight);

  let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
    ordered[0].x, ordered[0].y,
    ordered[1].x, ordered[1].y,
    ordered[2].x, ordered[2].y,
    ordered[3].x, ordered[3].y
  ]);
  let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
    0, 0,
    maxWidth, 0,
    maxWidth, maxHeight,
    0, maxHeight
  ]);
  let M = cv.getPerspectiveTransform(srcTri, dstTri);
  let dst = new cv.Mat();
  cv.warpPerspective(src, dst, M, new cv.Size(maxWidth, maxHeight));

  resCanvas.width = maxWidth;
  resCanvas.height = maxHeight;
  cv.imshow(resCanvas, dst);

  // cleanup
  src.delete(); gray.delete(); edges.delete();
  contours.delete(); hierarchy.delete(); docContour.delete();
  srcTri.delete(); dstTri.delete(); M.delete(); dst.delete();
});
</script>
</body>
</html>
