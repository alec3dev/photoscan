<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Face Detection and Cropping</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    h1 {
      color: #333;
      text-align: center;
    }
    .upload-section {
      margin-bottom: 20px;
      padding: 15px;
      border: 2px dashed #ccc;
      border-radius: 5px;
      text-align: center;
    }
    .button {
      background-color: #4CAF50;
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }
    .button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .button:hover:not(:disabled) {
      background-color: #45a049;
    }
    .results {
      margin-top: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
    }
    .face-card {
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
      text-align: center;
      background-color: #f9f9f9;
    }
    .face-image {
      max-width: 100%;
      height: auto;
      border-radius: 3px;
    }
    .status {
      margin: 10px 0;
      padding: 10px;
      border-radius: 4px;
    }
    .loading {
      background-color: #e0f7fa;
      color: #006064;
    }
    .success {
      background-color: #e8f5e9;
      color: #2e7d32;
    }
    .error {
      background-color: #ffebee;
      color: #c62828;
    }
    textarea {
      width: 100%;
      height: 100px;
      margin: 10px 0;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: vertical;
    }
    .instructions {
      background-color: #fff3e0;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 20px;
    }
    .ratio-display {
      margin: 10px 0;
      font-weight: bold;
      color: #333;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Face Detection and Cropping Tool</h1>

    <div class="instructions">
      <h3>Instructions:</h3>
      <ol>
        <li>Upload an image containing faces</li>
        <li>Enter numbers/names (one per line) to assign to detected faces</li>
        <li>Click "Detect and Crop Faces" to process the image</li>
        <li>Download the cropped face images using the download buttons</li>
      </ol>
      <div class="ratio-display">Current Crop Ratio: 1.5:2 (Width:Height)</div>
    </div>

    <div class="upload-section">
      <h3>Upload Image</h3>
      <input type="file" id="imageUpload" accept="image/*">
      <div id="imagePreview"></div>
    </div>

    <div>
      <h3>Enter Identifiers (one per line):</h3>
      <textarea id="identifiers" placeholder="Enter numbers or names, one per line. These will be used as filenames for the cropped faces."></textarea>
    </div>

    <div>
      <button id="processButton" class="button" disabled>Detect and Crop Faces</button>
      <button id="downloadAllButton" class="button" disabled>Download All</button>
    </div>

    <div id="status" class="status"></div>

    <h3>Detected Faces:</h3>
    <div id="results" class="results"></div>
  </div>

  <!-- Face API.js -->
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>
  <!-- JSZip -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <script>
    let imageFile = null;
    let detectedFaces = [];

    const imageUpload = document.getElementById('imageUpload');
    const imagePreview = document.getElementById('imagePreview');
    const identifiersTextarea = document.getElementById('identifiers');
    const processButton = document.getElementById('processButton');
    const downloadAllButton = document.getElementById('downloadAllButton');
    const statusDiv = document.getElementById('status');
    const resultsDiv = document.getElementById('results');

    imageUpload.addEventListener('change', handleImageUpload);
    processButton.addEventListener('click', processImage);
    downloadAllButton.addEventListener('click', downloadAllFaces);

    async function initializeFaceAPI() {
      statusDiv.textContent = 'Loading face detection models...';
      statusDiv.className = 'status loading';
      try {
        await faceapi.nets.tinyFaceDetector.loadFromUri('https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/');
        await faceapi.nets.faceLandmark68Net.loadFromUri('https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/');
        statusDiv.textContent = 'Models loaded successfully. Ready to detect faces.';
        statusDiv.className = 'status success';
      } catch (error) {
        statusDiv.textContent = `Error loading models: ${error.message}`;
        statusDiv.className = 'status error';
        console.error(error);
      }
    }

    function handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      imageFile = file;
      resultsDiv.innerHTML = '';
      detectedFaces = [];
      downloadAllButton.disabled = true;
      const reader = new FileReader();
      reader.onload = function(e) {
        imagePreview.innerHTML = `<img src="${e.target.result}" style="max-width: 100%; max-height: 300px;">`;
        processButton.disabled = false;
      };
      reader.readAsDataURL(file);
    }

    function centerPoint(points) {
      const xs = points.map(p => p.x);
      const ys = points.map(p => p.y);
      return {
        x: xs.reduce((a,b)=>a+b,0)/points.length,
        y: ys.reduce((a,b)=>a+b,0)/points.length
      };
    }

    async function processImage() {
      if (!imageFile) return;
      statusDiv.textContent = 'Detecting faces...';
      statusDiv.className = 'status loading';
      processButton.disabled = true;
      try {
        const identifiers = identifiersTextarea.value.split('\n').map(id => id.trim()).filter(id => id !== '');
        const img = await faceapi.bufferToImage(imageFile);
        
        // Use multiple detection options to ensure we find all faces
        const options1 = new faceapi.TinyFaceDetectorOptions({ inputSize: 512, scoreThreshold: 0.3 });
        const options2 = new faceapi.TinyFaceDetectorOptions({ inputSize: 256, scoreThreshold: 0.2 });
        
        // Run detection with different parameters
        const detections1 = await faceapi.detectAllFaces(img, options1).withFaceLandmarks();
        const detections2 = await faceapi.detectAllFaces(img, options2).withFaceLandmarks();
        
        // Combine results and remove duplicates
        let allDetections = [...detections1, ...detections2];
        const uniqueDetections = [];
        const seenBoxes = new Set();
        
        for (const detection of allDetections) {
          const box = detection.detection.box;
          const key = `${Math.round(box.x)}_${Math.round(box.y)}_${Math.round(box.width)}_${Math.round(box.height)}`;
          
          if (!seenBoxes.has(key)) {
            seenBoxes.add(key);
            uniqueDetections.push(detection);
          }
        }
        
        if (uniqueDetections.length === 0) {
          statusDiv.textContent = 'No faces detected in the image.';
          statusDiv.className = 'status error';
          processButton.disabled = false;
          return;
        }
        
        statusDiv.textContent = `Detected ${uniqueDetections.length} faces. Processing...`;

        detectedFaces = uniqueDetections.map((detection, index) => {
          const landmarks = detection.landmarks;
          const box = detection.detection.box;
          
          // Get nose position
          const nose = landmarks.getNose();
          const noseCenter = centerPoint(nose);
          
          // Calculate face dimensions based on 1.5:2 ratio
          const faceHeight = box.height * 1.8;
          const faceWidth = faceHeight * 1.5 / 2; // 1.5:2 ratio
          
          // Calculate crop area centered on the nose
          let cropX = noseCenter.x - faceWidth / 2;
          let cropY = noseCenter.y - faceHeight / 2;
          
          // Adjust if crop goes outside image boundaries
          if (cropX < 0) cropX = 0;
          if (cropY < 0) cropY = 0;
          if (cropX + faceWidth > img.width) cropX = img.width - faceWidth;
          if (cropY + faceHeight > img.height) cropY = img.height - faceHeight;
          
          // If still outside boundaries (small image), adjust dimensions
          if (cropX < 0) {
            faceWidth += cropX; // Reduce width
            cropX = 0;
          }
          if (cropY < 0) {
            faceHeight += cropY; // Reduce height
            cropY = 0;
          }

          // Calculate rotation angle from eyes
          const leftEyeCenter = centerPoint(landmarks.getLeftEye());
          const rightEyeCenter = centerPoint(landmarks.getRightEye());
          const dx = rightEyeCenter.x - leftEyeCenter.x;
          const dy = rightEyeCenter.y - leftEyeCenter.y;
          const angle = Math.atan2(dy, dx); // radians

          // Create canvas for the cropped face
          const canvas = document.createElement('canvas');
          canvas.width = faceWidth;
          canvas.height = faceHeight;
          const ctx = canvas.getContext('2d');

          // Rotate and draw the face
          ctx.translate(faceWidth / 2, faceHeight / 2);
          ctx.rotate(-angle); // rotate to make eyes horizontal
          ctx.drawImage(
            img,
            cropX, cropY, faceWidth, faceHeight,
            -faceWidth / 2, -faceHeight / 2, faceWidth, faceHeight
          );
          ctx.setTransform(1,0,0,1,0,0);

          const identifier = index < identifiers.length ? identifiers[index] : `face_${index + 1}`;

          return {
            id: identifier,
            imageData: canvas.toDataURL('image/jpeg'),
            x: cropX,
            y: cropY,
            width: faceWidth,
            height: faceHeight
          };
        });

        // Sort faces by position (top to bottom, left to right)
        detectedFaces.sort((a, b) => {
          if (Math.abs(a.y - b.y) < a.height * 0.5) {
            return a.x - b.x;
          }
          return a.y - b.y;
        });
        
        // Update identifiers based on sorted order
        detectedFaces.forEach((face, index) => {
          if (index < identifiers.length) {
            face.id = identifiers[index];
          } else {
            face.id = `face_${index + 1}`;
          }
        });
        
        displayResults();
        statusDiv.textContent = `Successfully processed ${detectedFaces.length} faces.`;
        statusDiv.className = 'status success';
        downloadAllButton.disabled = false;
      } catch (error) {
        statusDiv.textContent = `Error processing image: ${error.message}`;
        statusDiv.className = 'status error';
        console.error(error);
        processButton.disabled = false;
      }
    }

    function displayResults() {
      resultsDiv.innerHTML = '';
      detectedFaces.forEach(face => {
        const card = document.createElement('div');
        card.className = 'face-card';
        card.innerHTML = `
          <img src="${face.imageData}" class="face-image" alt="Cropped face">
          <p>${face.id}</p>
          <button class="button download-btn" data-id="${face.id}">Download</button>
        `;
        resultsDiv.appendChild(card);
      });
      document.querySelectorAll('.download-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const id = btn.getAttribute('data-id');
          downloadFace(id);
        });
      });
    }

    function downloadFace(id) {
      const face = detectedFaces.find(f => f.id === id);
      if (!face) return;
      const link = document.createElement('a');
      link.href = face.imageData;
      link.download = `${id}.jpg`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    async function downloadAllFaces() {
      if (detectedFaces.length === 0) return;
      statusDiv.textContent = 'Preparing download...';
      statusDiv.className = 'status loading';
      try {
        const zip = new JSZip();
        detectedFaces.forEach(face => {
          const data = face.imageData.split(',')[1];
          const blob = base64ToBlob(data, 'image/jpeg');
          zip.file(`${face.id}.jpg`, blob);
        });
        const content = await zip.generateAsync({type: 'blob'});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = 'cropped_faces.zip';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        statusDiv.textContent = 'Download prepared successfully.';
        statusDiv.className = 'status success';
      } catch (error) {
        statusDiv.textContent = `Error creating zip file: ${error.message}`;
        statusDiv.className = 'status error';
        console.error(error);
      }
    }

    function base64ToBlob(base64, mimeType) {
      const byteCharacters = atob(base64);
      const byteArrays = [];
      for (let offset = 0; offset < byteCharacters.length; offset += 512) {
        const slice = byteCharacters.slice(offset, offset + 512);
        const byteNumbers = new Array(slice.length);
        for (let i = 0; i < slice.length; i++) {
          byteNumbers[i] = slice.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        byteArrays.push(byteArray);
      }
      return new Blob(byteArrays, {type: mimeType});
    }

    initializeFaceAPI();
  </script>
</body>
</html>
